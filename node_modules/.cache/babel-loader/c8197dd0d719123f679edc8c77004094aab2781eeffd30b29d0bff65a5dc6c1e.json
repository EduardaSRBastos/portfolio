{"ast":null,"code":"'use client';\n\n// src/use-tabs.ts\nimport _objectSpread from \"D:/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"D:/portfolio/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectWithoutProperties from \"D:/portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _slicedToArray from \"D:/portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _excluded = [\"defaultIndex\", \"onChange\", \"index\", \"isManual\", \"isLazy\", \"lazyBehavior\", \"orientation\", \"direction\"],\n  _excluded2 = [\"isDisabled\", \"isFocusable\"],\n  _excluded3 = [\"children\"];\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { lazyDisclosure } from \"@chakra-ui/lazy-utils\";\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { useCallback, useEffect, useRef, useState, useId, createElement } from \"react\";\nvar _createDescendantCont = createDescendantContext(),\n  _createDescendantCont2 = _slicedToArray(_createDescendantCont, 4),\n  TabsDescendantsProvider = _createDescendantCont2[0],\n  useTabsDescendantsContext = _createDescendantCont2[1],\n  useTabsDescendants = _createDescendantCont2[2],\n  useTabsDescendant = _createDescendantCont2[3];\nfunction useTabs(props) {\n  var _a;\n  var defaultIndex = props.defaultIndex,\n    onChange = props.onChange,\n    index = props.index,\n    isManual = props.isManual,\n    isLazy = props.isLazy,\n    _props$lazyBehavior = props.lazyBehavior,\n    lazyBehavior = _props$lazyBehavior === void 0 ? \"unmount\" : _props$lazyBehavior,\n    _props$orientation = props.orientation,\n    orientation = _props$orientation === void 0 ? \"horizontal\" : _props$orientation,\n    _props$direction = props.direction,\n    direction = _props$direction === void 0 ? \"ltr\" : _props$direction,\n    htmlProps = _objectWithoutProperties(props, _excluded);\n  var _useState = useState(defaultIndex != null ? defaultIndex : 0),\n    _useState2 = _slicedToArray(_useState, 2),\n    focusedIndex = _useState2[0],\n    setFocusedIndex = _useState2[1];\n  var _useControllableState = useControllableState({\n      defaultValue: defaultIndex != null ? defaultIndex : 0,\n      value: index,\n      onChange: onChange\n    }),\n    _useControllableState2 = _slicedToArray(_useControllableState, 2),\n    selectedIndex = _useControllableState2[0],\n    setSelectedIndex = _useControllableState2[1];\n  useEffect(function () {\n    if (index != null) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  var descendants = useTabsDescendants();\n  var uuid = useId();\n  var uid = (_a = props.id) != null ? _a : uuid;\n  var id = \"tabs-\".concat(uid);\n  return {\n    id: id,\n    selectedIndex: selectedIndex,\n    focusedIndex: focusedIndex,\n    setSelectedIndex: setSelectedIndex,\n    setFocusedIndex: setFocusedIndex,\n    isManual: isManual,\n    isLazy: isLazy,\n    lazyBehavior: lazyBehavior,\n    orientation: orientation,\n    descendants: descendants,\n    direction: direction,\n    htmlProps: htmlProps\n  };\n}\nvar _createContext = createContext({\n    name: \"TabsContext\",\n    errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n  }),\n  _createContext2 = _slicedToArray(_createContext, 2),\n  TabsProvider = _createContext2[0],\n  useTabsContext = _createContext2[1];\nfunction useTabList(props) {\n  var _useTabsContext = useTabsContext(),\n    focusedIndex = _useTabsContext.focusedIndex,\n    orientation = _useTabsContext.orientation,\n    direction = _useTabsContext.direction;\n  var descendants = useTabsDescendantsContext();\n  var onKeyDown = useCallback(function (event) {\n    var _keyMap;\n    var nextTab = function nextTab() {\n      var _a;\n      var next = descendants.nextEnabled(focusedIndex);\n      if (next) (_a = next.node) == null ? void 0 : _a.focus();\n    };\n    var prevTab = function prevTab() {\n      var _a;\n      var prev = descendants.prevEnabled(focusedIndex);\n      if (prev) (_a = prev.node) == null ? void 0 : _a.focus();\n    };\n    var firstTab = function firstTab() {\n      var _a;\n      var first = descendants.firstEnabled();\n      if (first) (_a = first.node) == null ? void 0 : _a.focus();\n    };\n    var lastTab = function lastTab() {\n      var _a;\n      var last = descendants.lastEnabled();\n      if (last) (_a = last.node) == null ? void 0 : _a.focus();\n    };\n    var isHorizontal = orientation === \"horizontal\";\n    var isVertical = orientation === \"vertical\";\n    var eventKey = event.key;\n    var ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\";\n    var ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\";\n    var keyMap = (_keyMap = {}, _defineProperty(_keyMap, ArrowStart, function () {\n      return isHorizontal && prevTab();\n    }), _defineProperty(_keyMap, ArrowEnd, function () {\n      return isHorizontal && nextTab();\n    }), _defineProperty(_keyMap, \"ArrowDown\", function ArrowDown() {\n      return isVertical && nextTab();\n    }), _defineProperty(_keyMap, \"ArrowUp\", function ArrowUp() {\n      return isVertical && prevTab();\n    }), _defineProperty(_keyMap, \"Home\", firstTab), _defineProperty(_keyMap, \"End\", lastTab), _keyMap);\n    var action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, focusedIndex, orientation, direction]);\n  return _objectSpread(_objectSpread({}, props), {}, {\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  });\n}\nfunction useTab(props) {\n  var _props$isDisabled = props.isDisabled,\n    isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled,\n    _props$isFocusable = props.isFocusable,\n    isFocusable = _props$isFocusable === void 0 ? false : _props$isFocusable,\n    htmlProps = _objectWithoutProperties(props, _excluded2);\n  var _useTabsContext2 = useTabsContext(),\n    setSelectedIndex = _useTabsContext2.setSelectedIndex,\n    isManual = _useTabsContext2.isManual,\n    id = _useTabsContext2.id,\n    setFocusedIndex = _useTabsContext2.setFocusedIndex,\n    selectedIndex = _useTabsContext2.selectedIndex;\n  var _useTabsDescendant = useTabsDescendant({\n      disabled: isDisabled && !isFocusable\n    }),\n    index = _useTabsDescendant.index,\n    register = _useTabsDescendant.register;\n  var isSelected = index === selectedIndex;\n  var onClick = function onClick() {\n    setSelectedIndex(index);\n  };\n  var onFocus = function onFocus() {\n    setFocusedIndex(index);\n    var isDisabledButFocusable = isDisabled && isFocusable;\n    var shouldSelect = !isManual && !isDisabledButFocusable;\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n  var clickableProps = useClickable(_objectSpread(_objectSpread({}, htmlProps), {}, {\n    ref: mergeRefs(register, props.ref),\n    isDisabled: isDisabled,\n    isFocusable: isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  }));\n  var type = \"button\";\n  return _objectSpread(_objectSpread({}, clickableProps), {}, {\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type: type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? void 0 : callAllHandlers(props.onFocus, onFocus)\n  });\n}\nvar _createContext3 = createContext({}),\n  _createContext4 = _slicedToArray(_createContext3, 2),\n  TabPanelProvider = _createContext4[0],\n  useTabPanelContext = _createContext4[1];\nfunction useTabPanels(props) {\n  var context = useTabsContext();\n  var id = context.id,\n    selectedIndex = context.selectedIndex;\n  var validChildren = getValidChildren(props.children);\n  var children = validChildren.map(function (child, index) {\n    return createElement(TabPanelProvider, {\n      key: index,\n      value: {\n        isSelected: index === selectedIndex,\n        id: makeTabPanelId(id, index),\n        tabId: makeTabId(id, index),\n        selectedIndex: selectedIndex\n      }\n    }, child);\n  });\n  return _objectSpread(_objectSpread({}, props), {}, {\n    children: children\n  });\n}\nfunction useTabPanel(props) {\n  var children = props.children,\n    htmlProps = _objectWithoutProperties(props, _excluded3);\n  var _useTabsContext3 = useTabsContext(),\n    isLazy = _useTabsContext3.isLazy,\n    lazyBehavior = _useTabsContext3.lazyBehavior;\n  var _useTabPanelContext = useTabPanelContext(),\n    isSelected = _useTabPanelContext.isSelected,\n    id = _useTabPanelContext.id,\n    tabId = _useTabPanelContext.tabId;\n  var hasBeenSelected = useRef(false);\n  if (isSelected) {\n    hasBeenSelected.current = true;\n  }\n  var shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected: isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior\n  });\n  return _objectSpread(_objectSpread({\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0\n  }, htmlProps), {}, {\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id: id\n  });\n}\nfunction useTabIndicator() {\n  var context = useTabsContext();\n  var descendants = useTabsDescendantsContext();\n  var selectedIndex = context.selectedIndex,\n    orientation = context.orientation;\n  var isHorizontal = orientation === \"horizontal\";\n  var isVertical = orientation === \"vertical\";\n  var _useState3 = useState(function () {\n      if (isHorizontal) return {\n        left: 0,\n        width: 0\n      };\n      if (isVertical) return {\n        top: 0,\n        height: 0\n      };\n      return void 0;\n    }),\n    _useState4 = _slicedToArray(_useState3, 2),\n    rect = _useState4[0],\n    setRect = _useState4[1];\n  var _useState5 = useState(false),\n    _useState6 = _slicedToArray(_useState5, 2),\n    hasMeasured = _useState6[0],\n    setHasMeasured = _useState6[1];\n  useSafeLayoutEffect(function () {\n    if (selectedIndex == null) return;\n    var tab = descendants.item(selectedIndex);\n    if (tab == null) return;\n    if (isHorizontal) {\n      setRect({\n        left: tab.node.offsetLeft,\n        width: tab.node.offsetWidth\n      });\n    }\n    if (isVertical) {\n      setRect({\n        top: tab.node.offsetTop,\n        height: tab.node.offsetHeight\n      });\n    }\n    var id = requestAnimationFrame(function () {\n      setHasMeasured(true);\n    });\n    return function () {\n      if (id) {\n        cancelAnimationFrame(id);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, descendants]);\n  return _objectSpread({\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\"\n  }, rect);\n}\nfunction makeTabId(id, index) {\n  return \"\".concat(id, \"--tab-\").concat(index);\n}\nfunction makeTabPanelId(id, index) {\n  return \"\".concat(id, \"--tabpanel-\").concat(index);\n}\nexport { TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant, useTabs, TabsProvider, useTabsContext, useTabList, useTab, useTabPanels, useTabPanel, useTabIndicator };","map":{"version":3,"mappings":"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","names":["useClickable","createDescendantContext","createContext","useSafeLayoutEffect","useControllableState","getValidChildren","mergeRefs","lazyDisclosure","callAllHandlers","useCallback","useEffect","useRef","useState","useId","createElement","TabsDescendantsProvider","useTabsDescendantsContext","useTabsDescendants","useTabsDescendant","useTabs","props","defaultIndex","onChange","index","isManual","isLazy","lazyBehavior","orientation","direction","htmlProps","focusedIndex","setFocusedIndex","defaultValue","value","selectedIndex","setSelectedIndex","descendants","uuid","uid","_a","id","name","errorMessage","TabsProvider","useTabsContext","useTabList","onKeyDown","event","nextTab","next","nextEnabled","node","focus","prevTab","prev","prevEnabled","firstTab","first","firstEnabled","lastTab","last","lastEnabled","isHorizontal","isVertical","eventKey","key","ArrowStart","ArrowEnd","keyMap","action","preventDefault","role","useTab","isDisabled","isFocusable","disabled","register","isSelected","onClick","onFocus","isDisabledButFocusable","shouldSelect","clickableProps","ref","type","makeTabId","tabIndex","makeTabPanelId","TabPanelProvider","useTabPanelContext","useTabPanels","context","validChildren","children","map","child","tabId","useTabPanel","hasBeenSelected","current","shouldRenderChildren","wasSelected","enabled","mode","hidden","useTabIndicator","left","width","top","height","rect","setRect","hasMeasured","setHasMeasured","tab","item","offsetLeft","offsetWidth","offsetTop","offsetHeight","requestAnimationFrame","cancelAnimationFrame","position","transitionProperty","transitionDuration","transitionTimingFunction"],"sources":["D:\\portfolio\\node_modules\\@chakra-ui\\tabs\\src\\use-tabs.ts"],"sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport { createContext } from \"@chakra-ui/react-context\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { lazyDisclosure, LazyMode } from \"@chakra-ui/lazy-utils\"\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useId,\n  createElement,\n} from \"react\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  TabsDescendantsProvider,\n  useTabsDescendantsContext,\n  useTabsDescendants,\n  useTabsDescendant,\n] = createDescendantContext<HTMLButtonElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   * @default \"horizontal\"\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   *\n   * @default false\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance ðŸš€:\n   * If `true`, rendering of the tab panel's will be deferred until it is selected.\n   * @default false\n   */\n  isLazy?: boolean\n  /**\n   * Performance ðŸš€:\n   * The lazy behavior of tab panels' content when not active.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The content of inactive tab panels are always unmounted.\n   * - \"keepMounted\": The content of inactive tab panels is initially unmounted,\n   * but stays mounted when selected.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyMode\n  /**\n   * The writing mode direction.\n   *\n   * - When in RTL, the left and right navigation is flipped\n   * @default \"ltr\"\n   */\n  direction?: \"rtl\" | \"ltr\"\n}\n\n/**\n * Tabs hook that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n  const descendants = useTabsDescendants()\n\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n  const uuid = useId()\n  const uid = props.id ?? uuid\n  const id = `tabs-${uid}`\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<\n  ReturnType<typeof useTabs>,\n  \"htmlProps\" | \"descendants\"\n>\n\nexport const [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const { focusedIndex, orientation, direction } = useTabsContext()\n\n  const descendants = useTabsDescendantsContext()\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => {\n        const next = descendants.nextEnabled(focusedIndex)\n        if (next) next.node?.focus()\n      }\n      const prevTab = () => {\n        const prev = descendants.prevEnabled(focusedIndex)\n        if (prev) prev.node?.focus()\n      }\n      const firstTab = () => {\n        const first = descendants.firstEnabled()\n        if (first) first.node?.focus()\n      }\n      const lastTab = () => {\n        const last = descendants.lastEnabled()\n        if (last) last.node?.focus()\n      }\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = event.key\n\n      const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\"\n      const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\"\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        [ArrowStart]: () => isHorizontal && prevTab(),\n        [ArrowEnd]: () => isHorizontal && nextTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, focusedIndex, orientation, direction],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true` and `isDisabled`, the `Tab` will be focusable but not interactive.\n   * @default false\n   */\n  isFocusable?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled = false, isFocusable = false, ...htmlProps } = props\n\n  const { setSelectedIndex, isManual, id, setFocusedIndex, selectedIndex } =\n    useTabsContext()\n\n  const { index, register } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    setFocusedIndex(index)\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\nconst [TabPanelProvider, useTabPanelContext] = createContext<{\n  isSelected: boolean\n  id: string\n  tabId: string\n  selectedIndex: number\n}>({})\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    createElement(\n      TabPanelProvider,\n      {\n        key: index,\n        value: {\n          isSelected: index === selectedIndex,\n          id: makeTabPanelId(id, index),\n          tabId: makeTabId(id, index),\n          selectedIndex,\n        },\n      },\n      child,\n    ),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Record<string, any>) {\n  const { children, ...htmlProps } = props\n  const { isLazy, lazyBehavior } = useTabsContext()\n  const { isSelected, id, tabId } = useTabPanelContext()\n\n  const hasBeenSelected = useRef(false)\n  if (isSelected) {\n    hasBeenSelected.current = true\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior,\n  })\n\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n  const descendants = useTabsDescendantsContext()\n\n  const { selectedIndex, orientation } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return\n\n    const tab = descendants.item(selectedIndex)\n    if (tab == null) return\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal) {\n      setRect({ left: tab.node.offsetLeft, width: tab.node.offsetWidth })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical) {\n      setRect({ top: tab.node.offsetTop, height: tab.node.offsetHeight })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, descendants])\n\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}